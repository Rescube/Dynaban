----------------------------------------------------------------------------------
-- Company: Universite Bordeaux 1 departement EEA
-- Engineer: Autogenerated code 
--
-- Create Date:    
-- Design Name:
-- Module Name:    band_pass_alu - Behavioral
-- Project Name:
-- Target Devices:
-- Tool versions:
-- Description:
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;-- use signed numbers for numerical computations
entity band_pass_alu is
Port ( ent       : in   STD_LOGIC_VECTOR (15 downto 0); --N=16 bits
       sor       : out  STD_LOGIC_VECTOR (15 downto 0); --N=16 bits
       clk_50MHz : in std_logic ;
       f_ech     : in std_logic);
end band_pass_alu;
architecture Behavioral of RII_exemple is
 signal tmp_1, tmp_3, x1_2, x2_2, opx2_2, x1_3, x2_3, opx2_3, x1_4, x2_4 : signed (15 downto 0) := "0000000000000000";-- signaux intermediaires sur 16 bits,  niveau 0
 signal opx2_4, x1_5, x2_5, opx2_5, x1_6, x2_6, opx2_6, x1_7, x2_7, opx2_7 : signed (15 downto 0) := "0000000000000000";-- signaux intermediaires sur 16 bits,  niveau 0
 signal output_16 : signed (15 downto 0) := "0000000000000000";-- signaux intermediaires sur 16 bits,  niveau 0
 signal tmp_2, tmp_4, tmp_5, tmp_6, tmp_7, tmp_8, tmp_9, tmp_10, tmp_11, tmp_12 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_13, tmp_14, tmp_15, tmp_19, tmp_20, tmp_21, tmp_22, tmp_23, tmp_24, tmp_25 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_26, tmp_27, tmp_28, tmp_29, tmp_33, tmp_34, tmp_35, tmp_36, tmp_37, tmp_38 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_39, tmp_40, tmp_41, tmp_42, tmp_43, tmp_47, tmp_48, tmp_49, tmp_50, tmp_51 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_52, tmp_53, tmp_54, tmp_55, tmp_56, tmp_57, tmp_61, tmp_62, tmp_63, tmp_64 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_65, tmp_66, tmp_67, tmp_68, tmp_69, tmp_70, tmp_71, tmp_75, tmp_76, tmp_77 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_78, tmp_79, tmp_80, tmp_81, tmp_82, tmp_83, tmp_84, tmp_85, tmp_89, tmp_90 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_91, tmp_92, tmp_93, tmp_94, tmp_95, tmp_96, tmp_97, tmp_98, tmp_99, tmp_100 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_101 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
begin
    ---------------------------------------------------------------------------------------------------------------
    -- begin of filter : convert 16 bits logic input :ent, to signed equivalent :tmp_1
    ---------------------------------------------------------------------------------------------------------------------
    tmp_1 <= signed(ent);
    tmp_2<= resize( tmp_1 , 32 );
    ---------------------------------------------
    -- code of cel 1
    ---------------------------------------------
     -- en<-en .2^0 
    tmp_3<= resize( tmp_2 , 16 ); -- en<-b0 . en 
    tmp_4 <= tmp_3 * to_signed(18122,16) ;
    tmp_89 <= shift_right(tmp_4,12) ; -- scale output of cel 1
    -- local output :tmp_89 of cel 1 will be accumulated
    ---------------------------------------------
    -- code of cel 2
    ---------------------------------------------
    tmp_5 <= shift_left(tmp_2,12) ; -- en<<L+LA ,L=-3,LA=15
      -- AR part of cel 2
    tmp_6 <= x2_2 * to_signed(14875,16) ; -- - a1 . x1 
    tmp_7 <= tmp_6 + tmp_5 ;
    tmp_8 <= opx2_2 * to_signed(-24468,16) ; -- - a2 . x2 
    tmp_9 <= tmp_8 + tmp_7 ;
    tmp_10 <= shift_right(tmp_9,14) ; -- vn<-en >> LA 
    tmp_11 <= tmp_10 + to_signed(1,32) ;
    tmp_12 <= shift_right(tmp_11,1) ;
    x1_2 <= tmp_12(15 downto 0); -- x1=vn  
      -- MA part of cel 2
    tmp_13 <= x2_2 * to_signed(-17693,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_14 <= opx2_2 * to_signed(-12304,16) ; -- b2 .op x2
    tmp_15 <= tmp_14 + tmp_13 ; -- output of cel 2
    -- x2_2 <- q(x1_2), avec q=1/z
    z_1: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_2 <= x1_2 ;
           end if;
      end if;
    end process;
    -- opx2_2 <- delay operator (x2_2)
    z_2: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_2 <= x2_2 ;
           end if;
      end if;
    end process;
    tmp_90 <= shift_right(tmp_15,2) ; -- scale output of cel 2
    -- accumulation of output: tmp_90 of cel 2 with local output: tmp_89
    tmp_91 <= tmp_89 + tmp_90 ;
    ---------------------------------------------
    -- code of cel 3
    ---------------------------------------------
    tmp_19 <= shift_left(tmp_2,9) ; -- en<<L+LA ,L=-5,LA=14
      -- AR part of cel 3
    tmp_20 <= x2_3 * to_signed(28233,16) ; -- - a1 . x1 
    tmp_21 <= tmp_20 + tmp_19 ;
    tmp_22 <= opx2_3 * to_signed(-14503,16) ; -- - a2 . x2 
    tmp_23 <= tmp_22 + tmp_21 ;
    tmp_24 <= shift_right(tmp_23,13) ; -- vn<-en >> LA 
    tmp_25 <= tmp_24 + to_signed(1,32) ;
    tmp_26 <= shift_right(tmp_25,1) ;
    x1_3 <= tmp_26(15 downto 0); -- x1=vn  
      -- MA part of cel 3
    tmp_27 <= x2_3 * to_signed(21938,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_28 <= opx2_3 * to_signed(-15298,16) ; -- b2 .op x2
    tmp_29 <= tmp_28 + tmp_27 ; -- output of cel 3
    -- x2_3 <- q(x1_3), avec q=1/z
    z_3: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_3 <= x1_3 ;
           end if;
      end if;
    end process;
    -- opx2_3 <- delay operator (x2_3)
    z_4: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_3 <= x2_3 ;
           end if;
      end if;
    end process;
    tmp_92 <= shift_right(tmp_29,1) ; -- scale output of cel 3
    -- accumulation of output: tmp_92 of cel 3 with local output: tmp_91
    tmp_93 <= tmp_91 + tmp_92 ;
    ---------------------------------------------
    -- code of cel 4
    ---------------------------------------------
    tmp_33 <= shift_left(tmp_2,13) ; -- en<<L+LA ,L=-2,LA=15
      -- AR part of cel 4
    tmp_34 <= x2_4 * to_signed(16926,16) ; -- - a1 . x1 
    tmp_35 <= tmp_34 + tmp_33 ;
    tmp_36 <= opx2_4 * to_signed(-13844,16) ; -- - a2 . x2 
    tmp_37 <= tmp_36 + tmp_35 ;
    tmp_38 <= shift_right(tmp_37,14) ; -- vn<-en >> LA 
    tmp_39 <= tmp_38 + to_signed(1,32) ;
    tmp_40 <= shift_right(tmp_39,1) ;
    x1_4 <= tmp_40(15 downto 0); -- x1=vn  
      -- MA part of cel 4
    tmp_41 <= x2_4 * to_signed(-19772,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_42 <= opx2_4 * to_signed(28624,16) ; -- b2 .op x2
    tmp_43 <= tmp_42 + tmp_41 ; -- output of cel 4
    -- x2_4 <- q(x1_4), avec q=1/z
    z_5: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_4 <= x1_4 ;
           end if;
      end if;
    end process;
    -- opx2_4 <- delay operator (x2_4)
    z_6: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_4 <= x2_4 ;
           end if;
      end if;
    end process;
    tmp_94 <= shift_right(tmp_43,2) ; -- scale output of cel 4
    -- accumulation of output: tmp_94 of cel 4 with local output: tmp_93
    tmp_95 <= tmp_93 + tmp_94 ;
    ---------------------------------------------
    -- code of cel 5
    ---------------------------------------------
    tmp_47 <= shift_left(tmp_2,10) ; -- en<<L+LA ,L=-4,LA=14
      -- AR part of cel 5
    tmp_48 <= x2_5 * to_signed(24470,16) ; -- - a1 . x1 
    tmp_49 <= tmp_48 + tmp_47 ;
    tmp_50 <= opx2_5 * to_signed(-11014,16) ; -- - a2 . x2 
    tmp_51 <= tmp_50 + tmp_49 ;
    tmp_52 <= shift_right(tmp_51,13) ; -- vn<-en >> LA 
    tmp_53 <= tmp_52 + to_signed(1,32) ;
    tmp_54 <= shift_right(tmp_53,1) ;
    x1_5 <= tmp_54(15 downto 0); -- x1=vn  
      -- MA part of cel 5
    tmp_55 <= x2_5 * to_signed(-12152,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_56 <= opx2_5 * to_signed(16483,16) ; -- b2 .op x2
    tmp_57 <= tmp_56 + tmp_55 ; -- output of cel 5
    -- x2_5 <- q(x1_5), avec q=1/z
    z_7: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_5 <= x1_5 ;
           end if;
      end if;
    end process;
    -- opx2_5 <- delay operator (x2_5)
    z_8: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_5 <= x2_5 ;
           end if;
      end if;
    end process;
     -- scale output of cel 5
    -- accumulation of output: tmp_57 of cel 5 with local output: tmp_95
    tmp_96 <= tmp_95 + tmp_57 ;
    ---------------------------------------------
    -- code of cel 6
    ---------------------------------------------
    tmp_61 <= shift_left(tmp_2,13) ; -- en<<L+LA ,L=-2,LA=15
      -- AR part of cel 6
    tmp_62 <= x2_6 * to_signed(24899,16) ; -- - a1 . x1 
    tmp_63 <= tmp_62 + tmp_61 ;
    tmp_64 <= opx2_6 * to_signed(-9880,16) ; -- - a2 . x2 
    tmp_65 <= tmp_64 + tmp_63 ;
    tmp_66 <= shift_right(tmp_65,14) ; -- vn<-en >> LA 
    tmp_67 <= tmp_66 + to_signed(1,32) ;
    tmp_68 <= shift_right(tmp_67,1) ;
    x1_6 <= tmp_68(15 downto 0); -- x1=vn  
      -- MA part of cel 6
    tmp_69 <= x2_6 * to_signed(20389,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_70 <= opx2_6 * to_signed(-7985,16) ; -- b2 .op x2
    tmp_71 <= tmp_70 + tmp_69 ; -- output of cel 6
    -- x2_6 <- q(x1_6), avec q=1/z
    z_9: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_6 <= x1_6 ;
           end if;
      end if;
    end process;
    -- opx2_6 <- delay operator (x2_6)
    z_10: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_6 <= x2_6 ;
           end if;
      end if;
    end process;
     -- scale output of cel 6
    -- accumulation of output: tmp_71 of cel 6 with local output: tmp_96
    tmp_97 <= tmp_96 + tmp_71 ;
    ---------------------------------------------
    -- code of cel 7
    ---------------------------------------------
    tmp_75 <= shift_left(tmp_2,11) ; -- en<<L+LA ,L=-3,LA=14
      -- AR part of cel 7
    tmp_76 <= x2_7 * to_signed(19404,16) ; -- - a1 . x1 
    tmp_77 <= tmp_76 + tmp_75 ;
    tmp_78 <= opx2_7 * to_signed(-7350,16) ; -- - a2 . x2 
    tmp_79 <= tmp_78 + tmp_77 ;
    tmp_80 <= shift_right(tmp_79,13) ; -- vn<-en >> LA 
    tmp_81 <= tmp_80 + to_signed(1,32) ;
    tmp_82 <= shift_right(tmp_81,1) ;
    x1_7 <= tmp_82(15 downto 0); -- x1=vn  
      -- MA part of cel 7
    tmp_83 <= x2_7 * to_signed(-22918,16) ; -- en<-b1 . x2 ,because b0=0
    tmp_84 <= opx2_7 * to_signed(6490,16) ; -- b2 .op x2
    tmp_85 <= tmp_84 + tmp_83 ; -- output of cel 7
    -- x2_7 <- q(x1_7), avec q=1/z
    z_11: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then x2_7 <= x1_7 ;
           end if;
      end if;
    end process;
    -- opx2_7 <- delay operator (x2_7)
    z_12: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opx2_7 <= x2_7 ;
           end if;
      end if;
    end process;
     -- scale output of cel 7
    -- accumulation of output: tmp_85 of cel 7 with local output: tmp_97
    tmp_98 <= tmp_97 + tmp_85 ;
    ----------------------------------------------------------
    -- end of filter, scale global output : tmp_98
    ----------------------------------------------------------
    tmp_99 <= shift_right(tmp_98,10) ;
    tmp_100 <= tmp_99 + to_signed(1,32) ;
    tmp_101 <= shift_right(tmp_100,1) ;
    output_16 <= tmp_101(15 downto 0);
    sor <= std_logic_vector(output_16);
end Behavioral;

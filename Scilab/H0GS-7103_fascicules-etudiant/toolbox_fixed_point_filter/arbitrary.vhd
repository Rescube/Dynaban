----------------------------------------------------------------------------------
-- Company: Universite Bordeaux 1 departement EEA
-- Engineer: Autogenerated code 
--
-- Create Date:    
-- Design Name:
-- Module Name:    arbitrary - Behavioral
-- Project Name:
-- Target Devices:
-- Tool versions:
-- Description:
----------------------------------------------------------------------------------
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.ALL;-- use signed numbers for numerical computations
entity arbitrary is
Port ( ent       : in   STD_LOGIC_VECTOR (15 downto 0); --N=16 bits
       sor       : out  STD_LOGIC_VECTOR (15 downto 0); --N=16 bits
       clk_50MHz : in std_logic ;
       f_ech     : in std_logic);
end arbitrary;
architecture Behavioral of RII_exemple is
 signal tmp_1, tmp_3, e_2, op_x1_2, x1_2, e_3, op_x1_3, x1_3, output_16 : signed (15 downto 0) := "0000000000000000";-- signaux intermediaires sur 16 bits,  niveau 0
 signal opi1_3, tmp_32, tmp_33, tmp_34, tmp_35, i1_3 : signed (17 downto 0) := "000000000000000000";-- signaux intermediaires sur 18 bits,  niveau 0
 signal opi1_2, tmp_16, tmp_17, tmp_18, tmp_19, i1_2 : signed (29 downto 0) := "000000000000000000000000000000";-- signaux intermediaires sur 30 bits,  niveau 0
 signal tmp_2, tmp_4, tmp_5, tmp_7, tmp_8, tmp_9, tmp_10, tmp_11, tmp_12, tmp_21 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_23, tmp_24, tmp_25, tmp_26, tmp_27, tmp_28, tmp_37, tmp_38, tmp_39, tmp_40 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
 signal tmp_41 : signed (31 downto 0) := "00000000000000000000000000000000";-- signaux intermediaires sur 32 bits,  niveau 0
begin
    ---------------------------------------------------------------------------------------------------------------
    -- begin of filter : convert 16 bits logic input :ent, to signed equivalent :tmp_1
    ---------------------------------------------------------------------------------------------------------------------
    tmp_1 <= signed(ent);
    tmp_2<= resize( tmp_1 , 32 );
    ---------------------------------------------
    -- code of cel 1
    ---------------------------------------------
     -- en<-en .2^0 
    tmp_3<= resize( tmp_2 , 16 ); -- en<-b0 . en 
    tmp_4 <= tmp_3 * to_signed(-24802,16) ;
    tmp_37 <= shift_right(tmp_4,14) ; -- scale output of cel 1
    -- local output :tmp_37 of cel 1 will be accumulated
    ---------------------------------------------
    -- code of cel 2
    ---------------------------------------------
    tmp_5 <= shift_right(tmp_4,8) ; -- vn<-en<<L ,L=-8
    e_2 <= tmp_5(15 downto 0);
    tmp_4= (int_32)0; -- sn<-0,because D=0 
    -- update state x1_2 of cel 2
    tmp_7 <= e_2 * to_signed(29657,16) ; -- accx<-b1.vn 
    tmp_8 <= op_x1_2 * to_signed(46,16) ; -- accx<-accx-a11 . op_x1_2 
    tmp_9 <= tmp_8 + tmp_7 ;
    tmp_10 <= shift_right(tmp_9,8) ; -- accx<-accx >> Lx1 
    x1_2 <= tmp_10(15 downto 0);
    tmp_11 <= op_x1_2 * to_signed(-23873,16) ; -- sn<-sn+C1 . x1_2 
    tmp_12 <= tmp_11 + tmp_4 ;
    -- op_x1_2 <- q(x1_2), avec q=(2^-13)/(z-[ 1 - (2^-13) ] )
    z_1: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opi1_2 <= i1_2 ;
           end if;
      end if;
    end process;
    op_x1_2 <= tmp_16(15 downto 0);
    tmp_17<= resize( x1_2 , 30 );
    tmp_18<= resize( op_x1_2 , 30 );
    tmp_19 <= tmp_17 - tmp_18 ;
    i1_2 <= tmp_19 + opi1_2 ;
    tmp_16 <= shift_right(opi1_2,13) ;
     -- scale output of cel 2
    -- accumulation of output: tmp_12 of cel 2 with local output: tmp_37
    tmp_38 <= tmp_37 + tmp_12 ;
    ---------------------------------------------
    -- code of cel 3
    ---------------------------------------------
    tmp_21 <= shift_right(tmp_12,1) ; -- vn<-en<<L ,L=-1
    e_3 <= tmp_21(15 downto 0);
    tmp_12= (int_32)0; -- sn<-0,because D=0 
    -- update state x1_3 of cel 3
    tmp_23 <= e_3 * to_signed(31308,16) ; -- accx<-b1.vn 
    tmp_24 <= op_x1_3 * to_signed(-6710,16) ; -- accx<-accx-a11 . op_x1_3 
    tmp_25 <= tmp_24 + tmp_23 ;
    tmp_26 <= shift_right(tmp_25,14) ; -- accx<-accx >> Lx1 
    x1_3 <= tmp_26(15 downto 0);
    tmp_27 <= op_x1_3 * to_signed(-18976,16) ; -- sn<-sn+C1 . x1_3 
    tmp_28 <= tmp_27 + tmp_12 ;
    -- op_x1_3 <- q(x1_3), avec q=(2^-1)/(z-[ 1 - (2^-1) ] )
    z_2: process(clk_50MHz, f_ech)
    begin
      if rising_edge(clk_50MHz) then if f_ech='1' then opi1_3 <= i1_3 ;
           end if;
      end if;
    end process;
    op_x1_3 <= tmp_32(15 downto 0);
    tmp_33<= resize( x1_3 , 18 );
    tmp_34<= resize( op_x1_3 , 18 );
    tmp_35 <= tmp_33 - tmp_34 ;
    i1_3 <= tmp_35 + opi1_3 ;
    tmp_32 <= shift_right(opi1_3,1) ;
    tmp_39 <= shift_right(tmp_28,13) ; -- scale output of cel 3
    -- accumulation of output: tmp_39 of cel 3 with local output: tmp_38
    tmp_40 <= tmp_38 + tmp_39 ;
    ----------------------------------------------------------
    -- end of filter, scale global output : tmp_40
    ----------------------------------------------------------
    tmp_41 <= shift_right(tmp_40,1) ;
    output_16 <= tmp_41(15 downto 0);
    sor <= std_logic_vector(output_16);
end Behavioral;
